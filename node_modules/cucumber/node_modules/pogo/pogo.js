(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
exports.while = function (conditionBody, body, cb) {
  var loop = function () {
    try {
      conditionBody(function (error, result) {
        if (error) {
          cb(error);
        } else if (result) {
          try {
            body(function (error, result) {
              if (error) {
                cb(error);
              } else {
                loop();
              }
            });
          } catch (error) {
            cb(error);
          }
        } else {
          cb();
        }
      });
    } catch (error) {
      cb(error);
    }
  };

  loop();
};

exports.for = function (test, incr, loop) {
  return new Promise(function (success, failure) {
    function testAndLoop(loopResult) {
      Promise.resolve(test()).then(function (testResult) {
        if (testResult) {
          Promise.resolve(loop()).then(incrTestAndLoop, failure);
        } else {
          success(loopResult);
        }
      }, failure);
    }

    function incrTestAndLoop (loopResult) {
      Promise.resolve(incr()).then(function () {
        testAndLoop(loopResult);
      }, failure);
    }

    testAndLoop();
  });
};

exports.promisify = function (fn) {
  return new Promise(function (onFulfilled, onRejected) {
    fn(function (error, result) {
      if (error) {
        onRejected(error);
      } else {
        onFulfilled(result);
      }
    });
  });
};

exports.listComprehension = function (items, areRanges, block) {
  return new Promise(function (onFulfilled, onRejected) {
    var indexes = [];
    var results = {};
    var completed = 0;
    var wasError = false;

    if (items.length > 0) {
      for (var n = 0; n < items.length; n++) {
        Promise.resolve(block(n, items[n], function (result, index) {
          indexes.push(index);
          results[index] = result;
        })).then(function (result) {
          completed++;

          if (completed == items.length && !wasError) {
            var sortedResults = [];

            indexes.sort();

            for (n = 0; n < indexes.length; n++) {
              if (areRanges) {
                sortedResults.push.apply(sortedResults, results[indexes[n]]);
              } else {
                sortedResults.push(results[indexes[n]]);
              }
            }

            onFulfilled(sortedResults);
          }
        }, onRejected);
      }
    } else {
      onFulfilled([]);
    }
  });
};

},{}],2:[function(require,module,exports){
(function() {
    var self = this;
    exports.class = function(prototype) {
        var self = this;
        var constructor;
        constructor = function() {
            var self = this;
            var args = Array.prototype.slice.call(arguments, 0, arguments.length);
            prototype.constructor.apply(self, args);
            return void 0;
        };
        constructor.prototype = prototype;
        return constructor;
    };
    exports.classExtending = function(baseConstructor, prototypeMembers) {
        var self = this;
        var prototypeConstructor, prototype, constructor;
        prototypeConstructor = function() {
            var self = this;
            var field;
            for (field in prototypeMembers) {
                (function(field) {
                    if (prototypeMembers.hasOwnProperty(field)) {
                        self[field] = prototypeMembers[field];
                    }
                })(field);
            }
            return void 0;
        };
        prototypeConstructor.prototype = baseConstructor.prototype;
        prototype = new prototypeConstructor();
        constructor = function() {
            var self = this;
            var args = Array.prototype.slice.call(arguments, 0, arguments.length);
            prototype.constructor.apply(self, args);
            return void 0;
        };
        constructor.prototype = prototype;
        return constructor;
    };
}).call(this);
},{}],3:[function(require,module,exports){
var _ = require('underscore');
require('./parser/runtime');
var codegenUtils = require('./terms/codegenUtils');

var loc = exports.loc = function (term, location) {
  var loc = {
    firstLine: location.firstLine,
    lastLine: location.lastLine,
    firstColumn: location.firstColumn,
    lastColumn: location.lastColumn
  };

  term.location = function () {
    return loc;
  };
  
  return term;
};

exports.oldTerm = function (members) {
  var cg = this;
  
  var constructor = function () {
    members.call(this);
  };
  constructor.prototype = cg.termPrototype;
  return new constructor();
};

},{"./parser/runtime":23,"./terms/codegenUtils":39,"underscore":110}],4:[function(require,module,exports){
(function() {
    var self = this;
    var $class, _;
    $class = require("./class").class;
    _ = require("underscore");
    module.exports = function(terms) {
        var self = this;
        var macroDirectory, createMacroDirectory;
        macroDirectory = $class({
            constructor: function() {
                var self = this;
                return self.nameTreeRoot = {};
            },
            nameNode: function(name) {
                var self = this;
                var nameTree;
                nameTree = self.nameTreeRoot;
                _(name).each(function(nameSegment) {
                    if (!nameTree.hasOwnProperty(nameSegment)) {
                        return nameTree = nameTree[nameSegment] = {};
                    } else {
                        return nameTree = nameTree[nameSegment];
                    }
                });
                return nameTree;
            },
            addMacro: function(name, createMacro) {
                var self = this;
                var nameTree;
                nameTree = self.nameNode(name);
                return nameTree["create macro"] = createMacro;
            },
            addWildCardMacro: function(name, matchMacro) {
                var self = this;
                var nameTree, matchMacros;
                nameTree = self.nameNode(name);
                matchMacros = void 0;
                if (!nameTree.hasOwnProperty("match macro")) {
                    matchMacros = nameTree["match macro"] = [];
                } else {
                    matchMacros = nameTree["match macro"];
                }
                return matchMacros.push(matchMacro);
            },
            findMacro: function(name) {
                var self = this;
                var findMatchingWildMacro, findMacroInTree;
                findMatchingWildMacro = function(wildMacros, name) {
                    var n, wildMacro, macro;
                    n = 0;
                    while (n < wildMacros.length) {
                        wildMacro = wildMacros[n];
                        macro = wildMacro(name);
                        if (macro) {
                            return macro;
                        }
                        ++n;
                    }
                    return void 0;
                };
                findMacroInTree = function(nameTree, name, index, wildMacros) {
                    var subtree;
                    if (index < name.length) {
                        if (nameTree.hasOwnProperty(name[index])) {
                            subtree = nameTree[name[index]];
                            if (subtree.hasOwnProperty("match macro")) {
                                wildMacros = subtree["match macro"].concat(wildMacros);
                            }
                            return findMacroInTree(subtree, name, index + 1, wildMacros);
                        } else {
                            return findMatchingWildMacro(wildMacros, name);
                        }
                    } else {
                        if (nameTree.hasOwnProperty("create macro")) {
                            return nameTree["create macro"];
                        } else {
                            return findMatchingWildMacro(wildMacros, name);
                        }
                    }
                };
                return findMacroInTree(self.nameTreeRoot, name, 0, []);
            }
        });
        return createMacroDirectory = function() {
            var args = Array.prototype.slice.call(arguments, 0, arguments.length);
            var gen1_c;
            gen1_c = function() {
                macroDirectory.apply(this, args);
            };
            gen1_c.prototype = macroDirectory.prototype;
            return new gen1_c();
        };
    };
}).call(this);
},{"./class":2,"underscore":110}],5:[function(require,module,exports){
var MemoryStream = function () {
  var buffer = [];
  
  this.write = function (str) {
    if (typeof str === 'undefined') {
      throw new Error('wrote undefined');
    }
    buffer.push(str);
  };
  
  var totalSizeOfBuffer = function () {
    var size = 0;
    
    for (var n in buffer) {
      size += buffer[n].length;
    }
    
    return size;
  };
  
  this.toString = function () {
    var str = "";
    
    for (var n in buffer) {
      str += buffer[n];
    }
    
    return str;
  };
};

exports.MemoryStream = MemoryStream;

},{}],6:[function(require,module,exports){
(function() {
    var self = this;
    var $class, codegenUtils;
    $class = require("./class").class;
    codegenUtils = require("./terms/codegenUtils");
    module.exports = function(terms) {
        var self = this;
        var moduleConstants;
        return moduleConstants = terms.term({
            constructor: function() {
                var self = this;
                self.namedDefinitions = {};
                return self.listeners = [];
            },
            defineAs: function(name, expression, gen1_options) {
                var self = this;
                var generated;
                generated = gen1_options !== void 0 && Object.prototype.hasOwnProperty.call(gen1_options, "generated") && gen1_options.generated !== void 0 ? gen1_options.generated : true;
                var canonicalName, existingDefinition, variable;
                canonicalName = codegenUtils.concatName(name);
                existingDefinition = self.namedDefinitions[canonicalName];
                if (existingDefinition) {
                    return existingDefinition.target;
                } else {
                    variable = function() {
                        if (generated) {
                            return terms.generatedVariable(name);
                        } else {
                            return terms.variable(name, {
                                couldBeMacro: false
                            });
                        }
                    }();
                    self.namedDefinitions[canonicalName] = function() {
                        var definition;
                        definition = terms.definition(variable, expression);
                        self.notifyNewDefinition(definition);
                        return definition;
                    }();
                    return variable;
                }
            },
            definitions: function() {
                var self = this;
                var defs, name;
                defs = [];
                for (name in self.namedDefinitions) {
                    (function(name) {
                        var definition;
                        definition = self.namedDefinitions[name];
                        defs.push(definition);
                    })(name);
                }
                return defs;
            },
            notifyNewDefinition: function(d) {
                var self = this;
                var gen2_items, gen3_i, listener;
                gen2_items = self.listeners;
                for (gen3_i = 0; gen3_i < gen2_items.length; ++gen3_i) {
                    listener = gen2_items[gen3_i];
                    listener(d);
                }
                return void 0;
            },
            onEachNewDefinition: function(block) {
                var self = this;
                return self.listeners.push(block);
            },
            generate: function(scope) {
                var self = this;
                return self.generateIntoBuffer(function(buffer) {
                    var gen4_items, gen5_i, def;
                    gen4_items = self.definitions();
                    for (gen5_i = 0; gen5_i < gen4_items.length; ++gen5_i) {
                        def = gen4_items[gen5_i];
                        buffer.write("var ");
                        buffer.write(def.generate(scope));
                        buffer.write(";");
                    }
                    return void 0;
                });
            }
        });
    };
}).call(this);
},{"./class":2,"./terms/codegenUtils":39}],7:[function(require,module,exports){
var _ = require('underscore');

module.exports = function (terminals) {
  var cg = this;
  return cg.oldTerm(function () {
    this.terminals = terminals;
    this.subterms('terminals');
    
    this.hasName = function () {
      return this.name().length > 0;
    };
    
    this.isCall = function () {
      if (this.hasName()) {
        return this.hasArguments();
      } else {
        return this.argumentTerminals().length > 1;
      }
    };
    
    this.name = function () {
      return this._name || (this._name = _(this.terminals).filter(function (terminal) {
        return terminal.identifier;
      }).map(function (identifier) {
        return identifier.identifier;
      }));
    };
    
    this.hasAsyncArgument = function () {
      return this._hasAsyncArgument || (this._hasAsyncArgument =
        _.any(this.terminals, function (t) { return t.isAsyncArgument; })
      );
    };
    
    this.hasFutureArgument = function () {
      return this._hasFutureArgument || (this._hasFutureArgument =
        _.any(this.terminals, function (t) { return t.isFutureArgument; })
      );
    };
    
    this.hasCallbackArgument = function () {
      return this._hasCallbackArgument || (this._hasCallbackArgument =
        _.any(this.terminals, function (t) { return t.isCallback; })
      );
    };
    
    this.hasArguments = function () {
      return this._hasArguments || (this._hasArguments =
        this.argumentTerminals().length > 0
      );
    };
    
    this.argumentTerminals = function() {
      if (this._argumentTerminals) {
        return this._argumentTerminals;
      } else {
        this._buildBlocks();
        return this._argumentTerminals =
          _.compact(_.map(this.terminals, function (terminal) {
            return terminal.arguments();
          }));
      }
    };

    this.arguments = function() {
      return this._arguments || (this._arguments = _.flatten(this.argumentTerminals()));
    };

    this.parameters = function (options) {
      var skipFirstParameter = options && options.skipFirstParameter;
	
      if (this._parameters) {
        return this._parameters;
      }
      
      var args = this.arguments()

      if (skipFirstParameter) {
          args = args.slice(1);
      }

      return this._parameters = _(args).map(function (arg) {
        return arg.parameter();
      });
    };
    
    this.hasParameters = function () {
      return this._hasParameters || (this._hasParameters =
        this.argumentTerminals().length > 0
      );
    };
    
    this._buildBlocks = function () {
      var parameters = [];
      var hasParameters = false;

      _(this.terminals).each(function (terminal) {
        if (terminal.isParameters) {
          parameters.push.apply(parameters, terminal.parameters);
          hasParameters = true;
        } else if (terminal.isBlock) {
          terminal.setParameters(parameters);
          terminal.notScope = hasParameters;
          parameters = [];
          hasParameters = false;
        }
      });
      
      _(parameters).each(function (parm) {
        cg.errors.addTermWithMessage(parm, 'block parameter with no block');
      });
    };
    
    this.hashEntry = function (options) {
      var withoutBlock = options && options.withoutBlock;
      
      var args = this.arguments();
      var name = this.name();
      
      if (withoutBlock && args.length > 0 && args[args.length - 1].isBlock) {
        args = args.slice(0, args.length - 1);
      }

      if (name.length > 0 && args.length === 1) {
        return cg.hashEntry(name, args[0]);
      }

      if (name.length > 0 && args.length === 0) {
        return cg.hashEntry(name);
      }
      
      if (name.length === 0 && args.length === 2 && args[0].isString) {
        return cg.hashEntry(args[0], args[1])
      }
      
      return cg.errors.addTermWithMessage(this, 'cannot be a hash entry');
    };
    
    this.hashEntryBlock = function () {
      var args = this.arguments();
      
      var lastArgument = args[args.length - 1];
      
      if (lastArgument && lastArgument.isBlock) {
        return lastArgument;
      }
    };
    
    this.hashKey = function () {
      var args = this.arguments();
      if (args.length === 1 && args[0].isString) {
        return args[0];
      } else if (!this.hasParameters() && !this.hasArguments() && this.hasName()) {
        return this.name();
      } else {
        return cg.errors.addTermWithMessage(this, 'cannot be a hash key');
      }
    }
  });
};

},{"underscore":110}],8:[function(require,module,exports){
(function() {
    var self = this;
    window.pogoscript = require("./compiler");
}).call(this);
},{"./compiler":10}],9:[function(require,module,exports){
var cg = require('../codeGenerator');

exports.codeGenerator = function (options) {
  var codegen = {};

  var term = require('../terms/terms')(codegen);

  codegen.term = term.term;
  codegen.termPrototype = term.termPrototype;
  codegen.moduleConstants = new (require('../moduleConstants')(codegen));
  codegen.generatedVariable = require('../terms/generatedVariable')(codegen);
  codegen.definition = require('../terms/definition')(codegen);
  codegen.javascript = require('../terms/javascript')(codegen);
  codegen.basicExpression = require('./basicExpression');
  codegen.splatArguments = require('../terms/splatArguments')(codegen);
  codegen.variable = require('../terms/variable')(codegen);
  codegen.selfExpression = require('../terms/selfExpression')(codegen);
  codegen.statements = require('../terms/statements')(codegen);
  codegen.asyncStatements = require('../terms/asyncStatements')(codegen);
  codegen.subStatements = require('../terms/subStatements')(codegen);
  codegen.closure = require('../terms/closure')(codegen);
  codegen.normalParameters = require('../terms/normalParameters')(codegen);
  codegen.splatParameters = require('../terms/splatParameters')(codegen);
  codegen.block = codegen.closure;
  codegen.parameters = require('../terms/parameters')(codegen);
  codegen.identifier = require('../terms/identifier')(codegen);
  codegen.integer = require('../terms/integer')(codegen);
  codegen.float = require('../terms/float')(codegen);
  codegen.normaliseString = cg.normaliseString;
  codegen.unindent = cg.unindent;
  codegen.normaliseInterpolatedString = cg.normaliseInterpolatedString;
  codegen.string = require('../terms/string')(codegen);
  codegen.interpolatedString = require('../terms/interpolatedString')(codegen);
  codegen.normaliseRegExp = cg.normaliseRegExp;
  codegen.regExp = require('../terms/regExp')(codegen);
  codegen.parseRegExp = cg.parseRegExp;
  codegen.module = require('../terms/module')(codegen);
  codegen.interpolation = cg.interpolation;
  codegen.list = require('../terms/list')(codegen);
  codegen.normaliseArguments = cg.normaliseArguments;
  codegen.argumentList = require('../terms/argumentList')(codegen);
  codegen.subExpression = require('../terms/subExpression')(codegen);
  codegen.fieldReference = require('../terms/fieldReference')(codegen);
  codegen.hash = require('../terms/hash')(codegen);
  codegen.asyncArgument = require('../terms/asyncArgument')(codegen);
  codegen.futureArgument = require('../terms/futureArgument')(codegen);
  codegen.complexExpression = require('./complexExpression');
  codegen.operatorExpression = require('../parser/operatorExpression')(codegen);
  codegen.unaryOperatorExpression = require('../parser/unaryOperatorExpression')(codegen);
  codegen.operator = require('../terms/operator')(codegen);
  codegen.callback = require('../terms/callback')(codegen);
  codegen.splat = require('../terms/splat')(codegen);
  codegen.range = require('../terms/range')(codegen);
  codegen.hashEntry = require('../terms/hashEntry')(codegen);
  codegen.concatName = cg.concatName;
  codegen.parseSplatParameters = cg.parseSplatParameters;
  codegen.collapse = cg.collapse;
  codegen.functionCall = require('../terms/functionCall')(codegen);
  codegen.scope = require('../terms/scope')(codegen);
  codegen.SymbolScope = require('../symbolScope').SymbolScope;
  codegen.macroDirectory = require('../macroDirectory')(codegen);
  codegen.boolean = require('../terms/boolean')(codegen);
  codegen.increment = require('../terms/increment')(codegen);
  codegen.typeof = require('../terms/typeof')(codegen);
  codegen.tryExpression = require('../terms/tryExpression')(codegen);
  codegen.ifExpression = require('../terms/ifExpression')(codegen);
  codegen.nil = require('../terms/nil')(codegen);
  codegen.continueStatement = require('../terms/continueStatement')(codegen);
  codegen.breakStatement = require('../terms/breakStatement')(codegen);
  codegen.throwStatement = require('../terms/throwStatement')(codegen);
  codegen.returnStatement = require('../terms/returnStatement')(codegen);
  codegen.methodCall = require('../terms/methodCall')(codegen);
  codegen.asyncResult = require('../terms/asyncResult')(codegen);
  codegen.indexer = require('../terms/indexer')(codegen);
  codegen.whileExpression = require('../terms/whileExpression')(codegen);
  codegen.whileStatement = codegen.whileExpression;
  codegen.withExpression = require('../terms/withExpression')(codegen);
  codegen.withStatement = codegen.withExpression;
  codegen.forExpression = require('../terms/forExpression')(codegen);
  codegen.forStatement = codegen.forExpression;
  codegen.forIn = require('../terms/forIn')(codegen);
  codegen.forEach = require('../terms/forEach')(codegen);
  codegen.newOperator = require('../terms/newOperator')(codegen);
  codegen.generator = require('../terms/generator')(codegen);
  codegen.listComprehension = require('../terms/listComprehension')(codegen);
  codegen.loc = loc;
  codegen.asyncCallback = require('../terms/asyncCallback')(codegen);
  codegen.continuationOrDefault = require('../terms/continuationOrDefault')(codegen);
  codegen.continuationFunction = codegen.variable(['continuation'], {couldBeMacro: false});
  codegen.continuationFunction.isContinuation = true;
  codegen.onFulfilledFunction = codegen.generatedVariable(['onFulfilled'], {couldBeMacro: false, tag: 'onFulfilled'});
  codegen.onFulfilledFunction.isContinuation = true;
  codegen.onRejectedFunction = codegen.generatedVariable(['onRejected'], {couldBeMacro: false, tag: 'onRejected'});
  codegen.callbackFunction = codegen.generatedVariable(['callback'], {couldBeMacro: false});
  codegen.resolveFunction = codegen.generatedVariable(['resolve'], {couldBeMacro: false});
  codegen.resolve = require('../resolve')(codegen);
  codegen.newPromise = require('../terms/newPromise')(codegen);
  codegen.promise = require('../terms/promise')(codegen);
  codegen.createPromise = require('../terms/createPromise')(codegen);
  codegen.promisify = require('../terms/promisify')(codegen);
  codegen.optional = cg.optional;
  codegen.postIncrement = cg.postIncrement;
  codegen.oldTerm = cg.oldTerm;
  codegen.semanticError = require('../terms/semanticError')(codegen);
  codegen.errors = require('./errors').errors(codegen);
  codegen.macros = require('./macros').macros(codegen);
  codegen.listMacros = require('./listMacros')(codegen);
  codegen.argumentUtils = require('../terms/argumentUtils')(codegen);
  codegen.closureParameterStrategies = require('../terms/closureParameterStrategies')(codegen);
  codegen.promisesModule = promisesModule(options);
  
  return codegen;
};

function promisesModule(options) {
  var moduleName = (options && options.promises) || 'bluebird';
  
  if (moduleName === 'none') {
    return undefined;
  } else {
    return moduleName;
  }
}

var loc = function (term, location) {
  var loc = {
    firstLine: location.first_line,
    lastLine: location.last_line,
    firstColumn: location.first_column,
    lastColumn: location.last_column
  };

  term.location = function () {
    return loc;
  };
  
  return term;
};

},{"../codeGenerator":3,"../macroDirectory":4,"../moduleConstants":6,"../parser/operatorExpression":20,"../parser/unaryOperatorExpression":24,"../resolve":26,"../symbolScope":27,"../terms/argumentList":28,"../terms/argumentUtils":29,"../terms/asyncArgument":30,"../terms/asyncCallback":31,"../terms/asyncResult":32,"../terms/asyncStatements":33,"../terms/boolean":34,"../terms/breakStatement":35,"../terms/callback":36,"../terms/closure":37,"../terms/closureParameterStrategies":38,"../terms/continuationOrDefault":40,"../terms/continueStatement":41,"../terms/createPromise":42,"../terms/definition":43,"../terms/fieldReference":44,"../terms/float":45,"../terms/forEach":46,"../terms/forExpression":47,"../terms/forIn":48,"../terms/functionCall":49,"../terms/futureArgument":50,"../terms/generatedVariable":51,"../terms/generator":52,"../terms/hash":53,"../terms/hashEntry":54,"../terms/identifier":55,"../terms/ifExpression":56,"../terms/increment":57,"../terms/indexer":58,"../terms/integer":59,"../terms/interpolatedString":60,"../terms/javascript":61,"../terms/list":62,"../terms/listComprehension":63,"../terms/methodCall":64,"../terms/module":65,"../terms/newOperator":66,"../terms/newPromise":67,"../terms/nil":68,"../terms/normalParameters":69,"../terms/operator":70,"../terms/parameters":71,"../terms/promise":72,"../terms/promisify":73,"../terms/range":74,"../terms/regExp":75,"../terms/returnStatement":76,"../terms/scope":77,"../terms/selfExpression":78,"../terms/semanticError":79,"../terms/splat":80,"../terms/splatArguments":81,"../terms/splatParameters":82,"../terms/statements":83,"../terms/string":85,"../terms/subExpression":86,"../terms/subStatements":87,"../terms/terms":88,"../terms/throwStatement":89,"../terms/tryExpression":90,"../terms/typeof":91,"../terms/variable":92,"../terms/whileExpression":93,"../terms/withExpression":94,"./basicExpression":7,"./complexExpression":11,"./errors":13,"./listMacros":18,"./macros":19}],10:[function(require,module,exports){
(function() {
    var self = this;
    var ms, createParser, createTerms, object, sm, beautify, serialise, sourceLocationPrinter;
    ms = require("../memorystream");
    createParser = require("./parser").createParser;
    createTerms = require("./codeGenerator").codeGenerator;
    object = require("./runtime").object;
    sm = require("source-map");
    beautify = function(code) {
        var uglify, ast, stream;
        uglify = require("uglify-js");
        ast = uglify.parse(code);
        stream = uglify.OutputStream({
            beautify: true
        });
        ast.print(stream);
        return stream.toString();
    };
    serialise = function(code) {
        if (code instanceof sm.SourceNode) {
            return code;
        } else {
            return new sm.SourceNode(0, 0, 0, code);
        }
    };
    exports.generateCode = function(term, terms, gen1_options) {
        var self = this;
        var inScope, global, returnResult, outputFilename, sourceMap;
        inScope = gen1_options !== void 0 && Object.prototype.hasOwnProperty.call(gen1_options, "inScope") && gen1_options.inScope !== void 0 ? gen1_options.inScope : true;
        global = gen1_options !== void 0 && Object.prototype.hasOwnProperty.call(gen1_options, "global") && gen1_options.global !== void 0 ? gen1_options.global : false;
        returnResult = gen1_options !== void 0 && Object.prototype.hasOwnProperty.call(gen1_options, "returnResult") && gen1_options.returnResult !== void 0 ? gen1_options.returnResult : false;
        outputFilename = gen1_options !== void 0 && Object.prototype.hasOwnProperty.call(gen1_options, "outputFilename") && gen1_options.outputFilename !== void 0 ? gen1_options.outputFilename : outputFilename;
        sourceMap = gen1_options !== void 0 && Object.prototype.hasOwnProperty.call(gen1_options, "sourceMap") && gen1_options.sourceMap !== void 0 ? gen1_options.sourceMap : false;
        var moduleTerm, code;
        moduleTerm = terms.module(term, {
            inScope: inScope,
            global: global,
            returnLastStatement: returnResult
        });
        code = serialise(moduleTerm.generateModule());
        if (sourceMap) {
            return code.toStringWithSourceMap({
                file: outputFilename
            });
        } else {
            return code.toString();
        }
    };
    exports.compile = function(pogo, gen2_options) {
        var self = this;
        var filename, inScope, ugly, global, returnResult, async, outputFilename, sourceMap, promises, terms;
        filename = gen2_options !== void 0 && Object.prototype.hasOwnProperty.call(gen2_options, "filename") && gen2_options.filename !== void 0 ? gen2_options.filename : void 0;
        inScope = gen2_options !== void 0 && Object.prototype.hasOwnProperty.call(gen2_options, "inScope") && gen2_options.inScope !== void 0 ? gen2_options.inScope : true;
        ugly = gen2_options !== void 0 && Object.prototype.hasOwnProperty.call(gen2_options, "ugly") && gen2_options.ugly !== void 0 ? gen2_options.ugly : false;
        global = gen2_options !== void 0 && Object.prototype.hasOwnProperty.call(gen2_options, "global") && gen2_options.global !== void 0 ? gen2_options.global : false;
        returnResult = gen2_options !== void 0 && Object.prototype.hasOwnProperty.call(gen2_options, "returnResult") && gen2_options.returnResult !== void 0 ? gen2_options.returnResult : false;
        async = gen2_options !== void 0 && Object.prototype.hasOwnProperty.call(gen2_options, "async") && gen2_options.async !== void 0 ? gen2_options.async : false;
        outputFilename = gen2_options !== void 0 && Object.prototype.hasOwnProperty.call(gen2_options, "outputFilename") && gen2_options.outputFilename !== void 0 ? gen2_options.outputFilename : void 0;
        sourceMap = gen2_options !== void 0 && Object.prototype.hasOwnProperty.call(gen2_options, "sourceMap") && gen2_options.sourceMap !== void 0 ? gen2_options.sourceMap : false;
        promises = gen2_options !== void 0 && Object.prototype.hasOwnProperty.call(gen2_options, "promises") && gen2_options.promises !== void 0 ? gen2_options.promises : void 0;
        terms = gen2_options !== void 0 && Object.prototype.hasOwnProperty.call(gen2_options, "terms") && gen2_options.terms !== void 0 ? gen2_options.terms : createTerms({
            promises: promises
        });
        var parser, statements, output, memoryStream, error;
        parser = createParser({
            terms: terms,
            filename: filename
        });
        statements = parser.parse(pogo);
        if (async) {
            statements.asyncify({
                returnCallToContinuation: returnResult
            });
        }
        output = exports.generateCode(statements, terms, {
            inScope: inScope,
            global: global,
            returnResult: returnResult,
            outputFilename: outputFilename,
            sourceMap: sourceMap
        });
        if (parser.errors.hasErrors()) {
            memoryStream = new ms.MemoryStream();
            parser.errors.printErrors(sourceLocationPrinter({
                filename: filename,
                source: pogo
            }), memoryStream);
            error = new Error(memoryStream.toString());
            error.isSemanticErrors = true;
            throw error;
        } else if (sourceMap) {
            output.map.setSourceContent(filename, pogo);
            return {
                code: output.code,
                map: JSON.parse(output.map.toString())
            };
        } else {
            if (!ugly) {
                return beautify(output);
            } else {
                return output;
            }
        }
    };
    exports.evaluate = function(pogo, gen3_options) {
        var self = this;
        var definitions, ugly, global;
        definitions = gen3_options !== void 0 && Object.prototype.hasOwnProperty.call(gen3_options, "definitions") && gen3_options.definitions !== void 0 ? gen3_options.definitions : {};
        ugly = gen3_options !== void 0 && Object.prototype.hasOwnProperty.call(gen3_options, "ugly") && gen3_options.ugly !== void 0 ? gen3_options.ugly : true;
        global = gen3_options !== void 0 && Object.prototype.hasOwnProperty.call(gen3_options, "global") && gen3_options.global !== void 0 ? gen3_options.global : false;
        var js, definitionNames, parameters, runScript, definitionValues;
        js = exports.compile(pogo, {
            ugly: ugly,
            inScope: !global,
            global: global,
            returnResult: !global
        });
        definitionNames = Object.keys(definitions);
        parameters = definitionNames.join(",");
        runScript = new Function(parameters, "return " + js + ";");
        definitionValues = function() {
            var gen4_results, gen5_items, gen6_i, name;
            gen4_results = [];
            gen5_items = definitionNames;
            for (gen6_i = 0; gen6_i < gen5_items.length; ++gen6_i) {
                name = gen5_items[gen6_i];
                (function(name) {
                    return gen4_results.push(definitions[name]);
                })(name);
            }
            return gen4_results;
        }();
        return runScript.apply(undefined, definitionValues);
    };
    sourceLocationPrinter = function(gen7_options) {
        var filename, source;
        filename = gen7_options !== void 0 && Object.prototype.hasOwnProperty.call(gen7_options, "filename") && gen7_options.filename !== void 0 ? gen7_options.filename : void 0;
        source = gen7_options !== void 0 && Object.prototype.hasOwnProperty.call(gen7_options, "source") && gen7_options.source !== void 0 ? gen7_options.source : void 0;
        return {
            linesInRange: function(range) {
                var self = this;
                var lines;
                lines = source.split(/\n/);
                return lines.slice(range.from - 1, range.to);
            },
            printLinesInRange: function(gen8_options) {
                var self = this;
                var prefix, from, to, buffer;
                prefix = gen8_options !== void 0 && Object.prototype.hasOwnProperty.call(gen8_options, "prefix") && gen8_options.prefix !== void 0 ? gen8_options.prefix : "";
                from = gen8_options !== void 0 && Object.prototype.hasOwnProperty.call(gen8_options, "from") && gen8_options.from !== void 0 ? gen8_options.from : void 0;
                to = gen8_options !== void 0 && Object.prototype.hasOwnProperty.call(gen8_options, "to") && gen8_options.to !== void 0 ? gen8_options.to : void 0;
                buffer = gen8_options !== void 0 && Object.prototype.hasOwnProperty.call(gen8_options, "buffer") && gen8_options.buffer !== void 0 ? gen8_options.buffer : buffer;
                var gen9_items, gen10_i, line;
                gen9_items = self.linesInRange({
                    from: from,
                    to: to
                });
                for (gen10_i = 0; gen10_i < gen9_items.length; ++gen10_i) {
                    line = gen9_items[gen10_i];
                    buffer.write(prefix + line + "\n");
                }
                return void 0;
            },
            printLocation: function(location, buffer) {
                var self = this;
                var spaces, markers;
                buffer.write(filename + ":" + location.firstLine + "\n");
                if (location.firstLine === location.lastLine) {
                    self.printLinesInRange({
                        from: location.firstLine,
                        to: location.lastLine,
                        buffer: buffer
                    });
                    spaces = self.times(" ", location.firstColumn);
                    markers = self.times("^", location.lastColumn - location.firstColumn);
                    return buffer.write(spaces + markers + "\n");
                } else {
                    return self.printLinesInRange({
                        prefix: "> ",
                        from: location.firstLine,
                        to: location.lastLine,
                        buffer: buffer
                    });
                }
            },
            times: function(s, n) {
                var self = this;
                var strings, i;
                strings = [];
                for (i = 0; i < n; ++i) {
                    strings.push(s);
                }
                return strings.join("");
            }
        };
    };
    exports.lex = function(pogo) {
        var self = this;
        var parser;
        parser = createParser({
            terms: createTerms()
        });
        return parser.lex(pogo);
    };
}).call(this);
},{"../memorystream":5,"./codeGenerator":9,"./parser":21,"./runtime":23,"source-map":100,"uglify-js":"qD98jl"}],11:[function(require,module,exports){
var _ = require('underscore');
var asyncControl = require('../asyncControl')

module.exports = function (listOfTerminals) {
  var terms = this;
  return terms.oldTerm(function () {
    this.isComplexExpression = true;
    this.basicExpressions = _(listOfTerminals).map(function (terminals) {
      return terms.basicExpression(terminals);
    });
    
    this.subterms('basicExpressions');

    this.head = function () {
      return this._firstExpression || (this._firstExpression = this.basicExpressions[0]);
    };
    
    this.tail = function () {
      return this._tail || (this._tail = this.basicExpressions.slice(1));
    };
    
    this.hasTail = function () {
      return this.tail().length > 0;
    };
    
    this.isAsyncCall = function () {
      return this.head().hasAsyncArgument();
    };

    this.isFutureCall = function () {
      return this.head().hasFutureArgument();
    };

    this.isCallbackCall = function () {
      return this.head().hasCallbackArgument();
    };
    
    this.tailBlock = function () {
      if (this._hasTailBlock) {
        return this._tailBlock;
      } else {
        var tail = this.tail();
        if (tail.length > 0) {
          var block = tail[tail.length - 1].hashEntryBlock();
          
          this._hasTailBlock = block;
          return this._tailBlock = block;
        } else {
          this._hasTailBlock = false;
          this._tailBlock = undefined;
        }
      }
    }
    
    this.arguments = function () {
      if (this._arguments) {
        return this._arguments;
      } else {
        var args = this.head().arguments();
        
        var tailBlock = this.tailBlock();
        
        if (tailBlock) {
          return this._arguments = args.concat(tailBlock);
        } else {
          return this._arguments = args;
        }
      }
    }
    
    this.hasArguments = function () {
      return this._hasArguments || (this._hasArguments = 
        this.head().hasArguments() || this.tailBlock()
      );
    };
    
    this.expression = function () {
      var head = this.head();

      if (head.hasName()) {
        if (this.hasArguments()) {
          return this.wrap(terms.functionCall(terms.variable(head.name(), {couldBeMacro: false, location: this.location()}), this.arguments(), {options: true}));
        } else {
          return this.wrap(terms.variable(head.name(), {location: this.location()}));
        }
      } else {
        if (!this.hasTail() && this.arguments().length === 1 && !this.head().isCall()) {
          return this.arguments()[0];
        } else {
          return this.wrap(terms.functionCall(this.arguments()[0], this.arguments().slice(1), {options: true}));
        }
      }
    };
    
    this.objectOperationExpression = function (object) {
      var head = this.head();

      if (head.hasName()) {
        if (this.hasArguments()) {
          return this.wrap(terms.methodCall(object, head.name(), this.arguments(), {options: true}));
        } else {
          return terms.fieldReference(object, head.name());
        }
      } else {
        if (!this.hasTail() && !head.isCall() && !this.isAsyncCall()) {
          return terms.indexer(object, this.arguments()[0]);
        } else {
          return this.wrap(terms.functionCall(terms.indexer(object, this.arguments()[0]), this.arguments().slice(1), {options: true}));
        }
      }
    };

    this.wrap = function (term) {
      if (this.isAsyncCall()) {
        term = terms.resolve(term);
      }

      return term;
    };
    
    this.parameters = function (options) {
      return this.head().parameters(options);
    };
    
    this.hasParameters = function () {
      return this._hasParameters || (this._hasParameters =
        this.head().hasParameters()
      );
    };
    
    this.hashEntry = function () {
      if (this.hasTail()) {
        return terms.errors.addTermsWithMessage(this.tail(), 'cannot be a hash entry');
      }
      return this.head().hashEntry();
    };
    
    this.objectOperationDefinition = function (object, source) {
      var self = this;
      
      return {
        expression: function () {
          if (self.head().hasName()) {
            if (self.hasParameters()) {
              var block = source.blockify(self.parameters(), {returnPromise: self.isAsyncCall(), redefinesSelf: true});
              return terms.definition(terms.fieldReference(object, self.head().name()), block, {assignment: true});
            } else {
              return terms.definition(terms.fieldReference(object, self.head().name()), source.scopify(), {assignment: true});
            }
          } else {
            if (!self.hasTail() && self.arguments().length === 1 && !self.isAsyncCall()) {
              return terms.definition(terms.indexer(object, self.arguments()[0]), source.scopify(), {assignment: true});
            } else {
              var block = source.blockify(self.parameters({skipFirstParameter: true}), {returnPromise: self.isAsyncCall(), redefinesSelf: true});
              return terms.definition(terms.indexer(object, self.arguments()[0]), block, {assignment: true});
            }
          }
        }
      };
    };
    
    this.objectOperation = function (object) {
      var complexExpression = this;
      
      return new function () {
        this.operation = complexExpression;
        this.object = object;
        
        this.expression = function () {
          return this.operation.objectOperationExpression(this.object);
        };
        
        this.definition = function (source) {
          return this.operation.objectOperationDefinition(this.object, source);
        };

        this.hashEntry = function () {
          return terms.errors.addTermWithMessage(this.expression(), 'cannot be a hash entry');
        };
      };
    };
    
    this.definition = function (source, options) {
      var self = this;
      var assignment = options && Object.hasOwnProperty.call(options, 'assignment') && options.assignment;
      
      if (self.head().hasName()) {
        if (self.hasParameters()) {
          return {
            expression: function () {
              return terms.definition(terms.variable(self.head().name(), {location: self.location()}), source.blockify(self.parameters(), {returnPromise: self.isAsyncCall()}), {assignment: assignment});
            },
            hashEntry: function (isOptionalArgument) {
              var block = source.blockify(self.parameters(), {returnPromise: self.isAsyncCall(), redefinesSelf: !isOptionalArgument});

              return terms.hashEntry(self.head().name(), block);
            }
          };
        } else {
          return {
            expression: function () {
              return terms.definition(terms.variable(self.head().name(), {location: self.location()}), source.scopify(), {assignment: assignment});
            },
            hashEntry: function () {
              return terms.hashEntry(self.head().hashKey(), source.scopify());
            }
          };
        }
      } else if (self.isAsyncCall()) {
        return {
          hashEntry: function () {
            var head = self.head();
            return terms.hashEntry(head.hashKey(), source.blockify ([], {async: true}));
          }
        };
      } else {
        return {
          hashEntry: function () {
            var head = self.head();
            return terms.hashEntry(head.hashKey(), source);
          }
        };
      }
    };
  });
};

},{"../asyncControl":1,"underscore":110}],12:[function(require,module,exports){
(function() {
    var self = this;
    var createDynamicLexer;
    exports.createDynamicLexer = createDynamicLexer = function(gen1_options) {
        var nextLexer, source;
        nextLexer = gen1_options !== void 0 && Object.prototype.hasOwnProperty.call(gen1_options, "nextLexer") && gen1_options.nextLexer !== void 0 ? gen1_options.nextLexer : void 0;
        source = gen1_options !== void 0 && Object.prototype.hasOwnProperty.call(gen1_options, "source") && gen1_options.source !== void 0 ? gen1_options.source : void 0;
        var lexer;
        lexer = {
            tokens: [],
            nextLexer: nextLexer,
            lex: function() {
                var self = this;
                var token;
                token = self.tokens.shift();
                if (token) {
                    self.yytext = token;
                    return token;
                } else {
                    token = self.nextLexer.lex();
                    self.yytext = self.nextLexer.yytext;
                    self.yylloc = self.nextLexer.yylloc;
                    self.yyleng = self.nextLexer.yyleng;
                    self.yylineno = self.nextLexer.yylineno;
                    self.match = self.nextLexer.match;
                    return token;
                }
            },
            showPosition: function() {
                var self = this;
                return self.nextLexer.showPosition();
            },
            setInput: function(input) {
                var self = this;
                return self.nextLexer.setInput(input);
            }
        };
        if (source) {
            lexer.setInput(source);
        }
        return lexer;
    };
}).call(this);
},{}],13:[function(require,module,exports){
var _ = require('underscore');

exports.errors = function (terms) {
  return new function () {
    this.errors = [];
  
    this.clear = function () {
      this.errors = [];
    };
  
    this.hasErrors = function () {
      return this.errors.length > 0;
    };
  
    this.printErrors = function (sourceFile, buffer) {
      _.each(this.errors, function (error) {
        error.printError(sourceFile, buffer);
      });
    };
  
    this.addTermWithMessage = function (term, message) {
      return this.addTermsWithMessage([term], message);
    };
  
    this.addTermsWithMessage = function (errorTerms, message) {
      var e = terms.semanticError (errorTerms, message);
      this.errors.push(e);
      return e;
    };
  };
};

},{"underscore":110}],14:[function(require,module,exports){
(function() {
    var self = this;
    var comments, identifier;
    comments = "\\s*((\\/\\*([^*](\\*+[^\\/]|))*(\\*\\/|$)|\\/\\/.*(\\r?\\n|$))\\s*)+";
    exports.identifier = identifier = function() {
        var ranges;
        ranges = "a-zA-Z\\u4E00-\\u9FFF\\u3400-\\u4DFF_$";
        return "[" + ranges + "][" + ranges + "0-9]*";
    }();
    exports.grammar = {
        lex: {
            startConditions: {
                interpolated_string: true,
                interpolated_string_terminal: true
            },
            rules: [ [ "^#![^\\n]*", "/* ignore hashbang */" ], [ " +", "/* ignore whitespace */" ], [ "\\s*$", "return yy.eof();" ], [ comments + "$", "return yy.eof();" ], [ comments, "var indentation = yy.indentation(yytext); if (indentation) { return indentation; }" ], [ "\\(\\s*", 'yy.setIndentation(yytext); if (yy.interpolation.interpolating()) {yy.interpolation.openBracket()} return "(";' ], [ "\\s*\\)", "if (yy.interpolation.interpolating()) {yy.interpolation.closeBracket(); if (yy.interpolation.finishedInterpolation()) {this.popState(); yy.interpolation.stopInterpolation()}} return yy.unsetIndentation(')');" ], [ "{\\s*", "yy.setIndentation(yytext); return '{';" ], [ "\\s*}", "return yy.unsetIndentation('}');" ], [ "\\[\\s*", "yy.setIndentation(yytext); return '[';" ], [ "\\s*\\]", "return yy.unsetIndentation(']')" ], [ "(\\r?\\n *)*\\r?\\n *", "return yy.indentation(yytext);" ], [ "0x[0-9a-fA-F]+", "return 'hex';" ], [ "[0-9]+\\.[0-9]+", "return 'float';" ], [ "[0-9]+", "return 'integer';" ], [ "@" + identifier, 'return "operator";' ], [ "\\.\\.\\.", 'return "...";' ], [ "([:;=?!.@~#%^&*+<>\\/?\\\\|-])+", "return yy.lexOperator(yy, yytext);" ], [ ",", 'return ",";' ], [ "r\\/([^\\\\\\/]*\\\\.)*[^\\/]*\\/(img|mgi|gim|igm|gmi|mig|im|ig|gm|mg|mi|gi|i|m|g|)", "return 'reg_exp';" ], [ identifier, "return 'identifier';" ], [ "$", "return 'eof';" ], [ "'([^']*'')*[^']*'", "return 'string';" ], [ '"', "this.begin('interpolated_string'); return 'start_interpolated_string';" ], [ [ "interpolated_string" ], "\\\\#", "return 'escaped_interpolated_string_terminal_start';" ], [ [ "interpolated_string" ], "#\\(", "yy.setIndentation('('