<!-- Copyright (c) 2015 Google Inc. All rights reserved. -->

<link rel="import" href="../bower_components/polymer/polymer.html">
<link rel="import" href="../bower_components/google-apis/google-maps-api.html">
<!-- <link rel="import" href="../bower_components/google-map/google-map-marker.html"> -->

<!--
Provides the Google Maps API Directions Service to provide directions
between a `startAddress` and `endAddress`.

See https://developers.google.com/maps/documentation/javascript/directions for more
information on the API.

#### Example:

    <template is="dom-bind">
      <google-map-directions map="{{map}}"
          start-address="San Francisco"
          end-address="Mountain View"
          travel-mode="TRANSIT"></google-map-directions>
      <google-map map="{{map}}" latitude="37.779"
                  longitude="-122.3892"></google-map>
    </template>

-->

<dom-module id="google-map-directions">
  <style>
    :host {
      display: none;
    }
  </style>
  <template>
    <google-maps-api
      api-key="[[apiKey]]"
      libraries="[[libraries]]"
      language="[[language]]"
      on-api-load="_mapApiLoaded"></google-maps-api>
  </template>
</dom-module>

<script>
  Polymer({

    is: 'google-map-directions',

/**
Fired whenever the directions service returns a result.

@event google-map-response
@param {Object} detail
@param {object} detail.response The directions service response.
*/
    properties: {
      /**
       * A Maps API key. To obtain an API key, see developers.google.com/maps/documentation/javascript/tutorial#api_key.
       */
      apiKey: String,

      /**
       * The Google map object.
       *
       * @type google.maps.Map
       */
      map: {
        type: Object,
        observer: '_mapChanged'
      },
      /**
       * Start address or latlng to get directions from.
       *
       * @type string|google.maps.LatLng
       */
      startAddress: {
        type: String,
        value: null
      },

      /**
       * End address or latlng for directions to end.
       *
       * @type string|google.maps.LatLng
       */
      endAddress: {
        type: String,
        value: null
      },

      /**
       * Waypoint addresses or latlng for waypoint directions.
       *
       * @type array|google.maps.LatLng
       */
      waypointAddresses: {
        type: Array,
        value: function() {
          this.waypointAddresses = [];
          this.splice('waypointAddresses', 0, 0);
        }
      },

      /**
       * Travel mode to use.  One of 'DRIVING', 'WALKING', 'BICYCLING', 'TRANSIT'.
       */
      travelMode: {
        type: String,
        value: 'DRIVING'
      },

      /**
       * A comma separated list (e.g. "places,geometry") of libraries to load
       * with this map. Defaults to "places". For more information see
       * https://developers.google.com/maps/documentation/javascript/libraries.
       *
       * Note, this needs to be set to the same value as the one used on <google-map>.
       * If you're overriding that element's `libraries` property, this one also
       * needs to be set to the Maps API loads the library code.
       */
      libraries: {
        type: String,
        value: 'places'
      },

      /**
       * The localized language to load the Maps API with. For more information
       * see https://developers.google.com/maps/documentation/javascript/basics#Language
       *
       * Note: the Maps API defaults to the preffered language setting of the browser.
       * Use this parameter to override that behavior.
       */
      language: {
        type: String,
        value: null
      },

      /**
       * The response from the directions service.
       *
       */
      response: {
        type: Object,
        observer: '_responseChanged',
        notify: true
      },

      suppressMarkers: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },

      notStopoverStyleWaypoints: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },

      mapMarkers: {
        type: Array,
        value: function() { return []; }
        // readOnly: true
      }
    },

    observers: [
      '_route(startAddress, endAddress, waypointAddresses.splices, travelMode)',
    ],

    _mapApiLoaded: function() {
      this._route();
    },

    _responseChanged: function() {
      if (this.directionsRenderer && this.response) {
        this.directionsRenderer.setDirections(this.response);
      }
    },

    _mapChanged: function() {
      if (this.map && this.map instanceof google.maps.Map) {
        if (!this.directionsRenderer) {
          this.directionsRenderer = new google.maps.DirectionsRenderer();
        }
        this.directionsRenderer.setMap(this.map);
        if(this.suppressMarkers || this.notStopoverStyleWaypoints) this.directionsRenderer.setOptions( { suppressMarkers: true } );
        this._responseChanged();
      } else {
        // If there is no more map, remove the directionsRenderer from the map and delete it.
        this.directionsRenderer.setMap(null);
        this.directionsRenderer = null;
      }
    },

    _route: function() {

      console.log("WP: ");
      console.log(this.waypointAddresses);
      // Abort attempts to _route if the API is not available yet or the
      // required attributes are blank.
      if (typeof google == 'undefined' || typeof google.maps == 'undefined' ||
          !this.startAddress || !this.endAddress) {
        return;
      }

      // Construct a directionsService if necessary.
      // Wait until here where the maps api has loaded and directions are actually needed.
      if (!this.directionsService) {
        this.directionsService = new google.maps.DirectionsService();
      }

      var request = {
        origin: this.startAddress,
        destination: this.endAddress,
        waypoints: this.waypointAddresses,
        travelMode: this.travelMode
      };

      // if(this.mapMarkers) this.mapMarkers.forEach(function(marker) {marker.setMap(null);});
      // this.set('mapMarkers', []);

      
      // this.set('mapMakers', markers);
      this.directionsService.route(request, function(response, status) {
        if (status == google.maps.DirectionsStatus.OK) {
          this.response = response;
          this.fire('google-map-response', {response: response});

          
          if(!this.suppressMarkers && this.notStopoverStyleWaypoints) {
            var thisMarkers = this.mapMarkers;
            var markers = [];

            var legs = response.routes[0].legs;
            var length = legs.length;
            if(length > 0) {
              var leg = legs[0];
              
              createMarker(markers, thisMarkers[0], this.map, leg.start_location, leg.start_address, "https://mts.googleapis.com/vt/icon/name=icons/spotlight/spotlight-waypoint-a.png&text=A&psize=16&font=fonts/Roboto-Regular.ttf&color=ff333333&ax=44&ay=48&scale=1", 1);

              for(var i = 1; i < length; i++) {
                leg = legs[i];
                createMarker(markers, thisMarkers[i], this.map, leg.start_location, leg.start_address, "https://maps.gstatic.com/mapfiles/dd-via.png", 0);
              }

              createMarker(markers, thisMarkers[i - 1], this.map, leg.end_location, leg.end_address, "https://mts.googleapis.com/vt/icon/name=icons/spotlight/spotlight-waypoint-b.png&text=B&psize=16&font=fonts/Roboto-Regular.ttf&color=ff333333&ax=44&ay=48&scale=1", 1);

              var size = thisMarkers.length;
              for(; i < size; i++) thisMarkers[i].setMap(null);

              this.mapMarkers = markers;
            }
          }
        }
      }.bind(this));
    }
  });

  createMarker = function(markers, previous, m, latLng, ttle, ico, zdex) {
    if(previous && previous.position.equals(latLng)) markers.push(previous);
    else {
      if(previous) previous.setMap(null);
      markers.push(new google.maps.Marker({
        map: m,
        position: latLng,
        title: ttle,
        // visible: true,
        icon: ico,
        zIndex: zdex
      }));
    }
  };
</script>
